const DailyChallenge = require("../models/DailyChallenge");
const User = require("../models/User");

const { generateUniqueQuestions } = require("./aiController");
const aiPrompt = require("../utils/aiPrompt");
// Import the raw AI caller to use custom prompt
const axios = require('axios');
const OPENROUTER_API_URL = process.env.OPENROUTER_API_URL || 'https://openrouter.ai/api/v1/chat/completions';
const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY;

// Helper to call AI
async function fetchAIChallenge() {
    const prompt = aiPrompt.generateDailyChallengePrompt(5);

    try {
        const res = await axios.post(OPENROUTER_API_URL, {
            model: "openai/gpt-4o-mini", // or preferred model
            messages: [{ role: 'user', content: prompt }],
            temperature: 0.7
        }, {
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${OPENROUTER_API_KEY}`,
                'HTTP-Referer': 'https://vivamate.com',
            }
        });

        const content = res.data?.choices?.[0]?.message?.content || "";
        const cleanContent = content.replace(/```json/g, "").replace(/```/g, "").trim();

        // Extract JSON
        const start = cleanContent.indexOf('{');
        const end = cleanContent.lastIndexOf('}');
        if (start === -1 || end === -1) throw new Error("Invalid JSON from AI");

        const json = JSON.parse(cleanContent.slice(start, end + 1));
        if (!json.questions || !Array.isArray(json.questions)) throw new Error("Invalid structure from AI");

        return json.questions;
    } catch (err) {
        // Quietly fail to console debug only, to avoid spamming prod logs
        if (process.env.NODE_ENV !== 'production') {
            console.debug("AI Gen Failed:", err.message);
        }
        // Explicit Fallback here to guarantee return
        return [
            { question: "What is the primary function of Redux?", options: ["Routing", "State Management", "Styling", "API Calls"], correctAnswer: "State Management", type: "multiple-choice" },
            { question: "Which method joins two arrays in JS?", options: ["push()", "pop()", "concat()", "join()"], correctAnswer: "concat()", type: "multiple-choice" },
            { question: "What does SQL stand for?", options: ["Structured Query Language", "Simple Query List", "Strong Question Language", "Safe Queue Link"], correctAnswer: "Structured Query Language", type: "multiple-choice" },
            { question: "In CSS, 'flex: 1' is shorthand for?", options: ["flex-grow", "flex-shrink", "flex-basis", "All three"], correctAnswer: "All three", type: "multiple-choice" },
            { question: "Which status code means 'Not Found'?", options: ["200", "500", "404", "401"], correctAnswer: "404", type: "multiple-choice" }
        ];
    }
}

// Get today's challenge OR create/update one 
// Note: We'll actually rotate this every 2 hours as requested.
const getDailyChallenge = async (req, res) => {
    try {
        // Current date label (YYYY-MM-DD-HH-Block)
        // To rotate every 2 hours, we divide hours by 2.
        const now = new Date();
        const dateKey = now.toISOString().split("T")[0];
        const block = Math.floor(now.getHours() / 2);
        const challengeKey = `${dateKey}-block-${block}`;

        let challenge = await DailyChallenge.findOne({ date: challengeKey });

        // If no challenge exists for this 2-hour block, generate strictly via AI
        if (!challenge) {
            console.log(`Generating new challenge for ${challengeKey}...`);
            let questions = await fetchAIChallenge();

            // Fallback if AI fails
            if (!questions || questions.length === 0) {
                questions = [
                    { question: "Fallback: What is React?", options: ["Lib", "Framework", "DB", "OS"], correctAnswer: "Lib", type: "multiple-choice" },
                    { question: "Fallback: 2+2?", options: ["3", "4", "5", "6"], correctAnswer: "4", type: "multiple-choice" },
                    { question: "Fallback: HTTP Success Code?", options: ["200", "400", "500", "300"], correctAnswer: "200", type: "multiple-choice" },
                    { question: "Fallback: SQL Command?", options: ["SELECT", "GET", "FETCH", "PULL"], correctAnswer: "SELECT", type: "multiple-choice" },
                    { question: "Fallback: JS specific?", options: ["Java", "Python", "ECMAScript", "C++"], correctAnswer: "ECMAScript", type: "multiple-choice" }
                ];
            }

            try {
                challenge = await DailyChallenge.create({
                    date: challengeKey,
                    title: "Live AI Challenge",
                    description: `Fresh interview questions generated by AI. (Block ${block})`,
                    xpReward: 300,
                    difficulty: "Varies",
                    questions: questions
                });
            } catch (createErr) {
                // Handle Race Condition: Duplicate Key Error (E11000)
                // If another request created it while we were generating, just fetch it
                if (createErr.code === 11000) {
                    challenge = await DailyChallenge.findOne({ date: challengeKey });
                } else {
                    throw createErr;
                }
            }
        }

        // Check if user already completed THIS specific block challenge
        if (!req.user) {
            console.error("getDailyChallenge: No user in request");
            return res.status(401).json({ message: "User not authenticated" });
        }

        const user = await User.findById(req.user);
        if (!user) {
            console.error("getDailyChallenge: User not found in DB", req.user);
            return res.status(404).json({ message: "User not found" });
        }

        const completed = user.completedChallenges.some(c => c.challengeId && c.challengeId.toString() === challenge._id.toString());

        // Hide correct answers
        const safeChallenge = challenge.toObject();
        safeChallenge.questions = safeChallenge.questions.map(q => ({
            _id: q._id,
            question: q.question,
            options: q.options,
            type: q.type
        }));

        res.json({ ...safeChallenge, completed });
    } catch (err) {
        console.error("getDailyChallenge Error:", err);
        res.status(500).json({ message: "Failed to fetch challenge", error: err.message });
    }
};

const submitChallenge = async (req, res) => {
    try {
        const { challengeId, answers } = req.body; // answers: { questionId: "answer" } OR array of answers
        const challenge = await DailyChallenge.findById(challengeId);

        if (!challenge) return res.status(404).json({ message: "Challenge not found" });

        const user = await User.findById(req.user);

        // Prevent double submission
        if (user.completedChallenges.some(c => c.challengeId && c.challengeId.toString() === challengeId)) {
            return res.status(400).json({ message: "Challenge already completed" });
        }

        let correctCount = 0;
        const results = [];

        // Grade each question
        challenge.questions.forEach((q, index) => {
            // Handle array or object input for answers
            const userAnswer = Array.isArray(answers) ? answers[index] : answers[q._id];
            const isCorrect = userAnswer === q.correctAnswer;
            if (isCorrect) correctCount++;
            results.push({ question: q.question, isCorrect, correctAns: q.correctAnswer, yourAns: userAnswer });
        });

        // XP Calculation
        const xpPerQuestion = challenge.xpReward / challenge.questions.length;
        const xpGained = Math.round(xpPerQuestion * correctCount);

        // STREAK LOGIC
        const today = new Date();
        const yesterday = new Date(today);
        yesterday.setDate(yesterday.getDate() - 1);

        let streakBonus = 0;

        if (user.lastChallengeDate) {
            const lastDate = new Date(user.lastChallengeDate);
            // Check if last date matches yesterday (ignoring time)
            if (lastDate.toDateString() === yesterday.toDateString()) {
                user.streak += 1;
                streakBonus = user.streak * 10; // 10 XP per streak day
            } else if (lastDate.toDateString() === today.toDateString()) {
                // Already did one today?
            } else {
                // Warning: Streak reset
                user.streak = 1;
                streakBonus = 10;
            }
        } else {
            user.streak = 1;
            streakBonus = 10;
        }

        user.lastChallengeDate = today;
        const totalXpEarned = xpGained + streakBonus;
        user.xp += totalXpEarned;

        user.completedChallenges.push({
            challengeId: challenge._id,
            date: today,
            score: correctCount,
            total: challenge.questions.length,
            xpEarned: totalXpEarned
        });

        // Badge Logic
        if (user.xp >= 100 && !user.badges.includes("Novice")) user.badges.push("Novice");
        if (user.xp >= 500 && !user.badges.includes("Warrior")) user.badges.push("Warrior");
        if (user.xp >= 1000 && !user.badges.includes("Legend")) user.badges.push("Legend");
        if (correctCount === challenge.questions.length && !user.badges.includes("Perfectionist")) user.badges.push("Perfectionist");
        if (user.streak >= 7 && !user.badges.includes("Streak Master")) user.badges.push("Streak Master");

        user.level = Math.floor(1 + user.xp / 500);

        await user.save();

        res.json({
            success: true,
            score: correctCount,
            total: challenge.questions.length,
            xpGained,
            streakBonus,
            currentStreak: user.streak,
            newTotalXp: user.xp,
            badges: user.badges,
            results
        });

    } catch (err) {
        console.error(err);
        res.status(500).json({ message: "Submission failed" });
    }
};

const getChallengeHistory = async (req, res) => {
    try {
        const user = await User.findById(req.user).populate({
            path: 'completedChallenges.challengeId',
            select: 'title date difficulty description xpReward'
        });

        if (!user) return res.status(404).json({ message: "User not found" });

        // Filter out null challenges (if deleted)
        const history = user.completedChallenges
            .filter(c => c.challengeId)
            .map(c => {
                // Robust XP Calculation for legacy data
                let finalXp = 0;
                if (c.xpEarned !== undefined) {
                    finalXp = c.xpEarned;
                } else if (c.score !== undefined && c.total !== undefined && c.total > 0) {
                    const reward = c.challengeId.xpReward || 200;
                    finalXp = Math.round((reward / c.total) * c.score);
                } else {
                    finalXp = 0; // Truly unknown/legacy
                }

                return {
                    id: c.challengeId._id,
                    title: c.challengeId.title,
                    date: c.date,
                    score: c.score,
                    total: c.total,
                    difficulty: c.challengeId.difficulty,
                    xpEarned: finalXp
                };
            })
            .reverse(); // Newest first

        res.json(history);
    } catch (err) {
        console.error("History Error:", err);
        res.status(500).json({ message: "Failed to fetch history" });
    }
};

const toggleBookmark = async (req, res) => {
    try {
        const { question, options, correctAnswer, type, questionId } = req.body;
        const user = await User.findById(req.user);

        // Check if exists based on question text (since ID might not be stable if AI gen)
        // Or if we trust questionId from FE
        const existingIndex = user.bookmarks.findIndex(b => b.question === question);

        let isBookmarked = false;

        if (existingIndex > -1) {
            // Remove
            user.bookmarks.splice(existingIndex, 1);
            isBookmarked = false;
        } else {
            // Add
            user.bookmarks.push({ questionId, question, options, correctAnswer, type });
            isBookmarked = true;
        }

        await user.save();
        res.json({ success: true, isBookmarked, bookmarks: user.bookmarks });

    } catch (err) {
        console.error("Bookmark Error:", err);
        res.status(500).json({ message: "Failed to update bookmark" });
    }
};

const getBookmarks = async (req, res) => {
    try {
        const user = await User.findById(req.user);
        res.json(user.bookmarks);
    } catch (err) {
        res.status(500).json({ message: "Failed to fetch bookmarks" });
    }
};

module.exports = {
    getDailyChallenge,
    submitChallenge,
    getChallengeHistory,
    toggleBookmark,
    getBookmarks
};
